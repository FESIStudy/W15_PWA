## PWA(Progressive Web Application)

- 모바일 기기에서 네이티브 앱과 같은 사용자 경험을 제공하는 **웹 앱**
    - 웹은 웹인데 점진적(progressive)으로 네이티브 앱 수준으로 근접해가는 웹 (2015년에 개념 등장)
- 전통적인 웹 앱과는 달리 **네이티브 앱과 유사한 기능을 제공**할 수 있으며, **오프라인에서도 작동이 가능**하다.
    - ex) 푸시 알림, 카메라, 마이크 기능 등
- 참고) [PWA 활용 사례 (스타벅스, 트위터)](https://yozm.wishket.com/magazine/detail/1969/)

<br/>

### PWA 조건
- 사용자의 기기에 **설치**가 가능할 것
- **오프라인, 저속도 환경**에서도 동작할 것 (리소스 캐싱)
- **백그라운드 동기화**가 가능할 것
- 사용자 재참여를 유도할 수 있도록 **푸시 알림**이 가능할 것
- 다양한 Web API를 사용하여 **네이티브 앱과 같은 사용성**을 갖출 것
- HTTPS 프로토콜을 통해 제공할 것 (보안, 안정성)

<br/>

### PWA를 가능하게 하는 요소

> PWA는 새롭게 개발된 기술이 아닌, **기존에 있던 기술을 조합하고 확장한 기술 표준**  
> → 기존에 존재하는 일반 웹도 필수 요구사항만 충족시키면 PWA로 전환할 수 있다.

1. **Web App Manifest JSON 파일**
    - 브라우저에게 PWA에 대한 메타 정보와 현재 웹 사이트가 유저의 데스크탑이나 모바일 장치에 어떻게 설치되어야 하는지에 대한 정보를 저장한 파일
    - 앱 이름, 아이콘, 테마 색상 정보 등을 포함
2. **service worker**
    - PWA의 핵심 기능인 푸시 알림, 백그라운드 동기화, 오프라인 환경 지원, 리소스 캐싱의 구현체를 담을 수 있는 스크립트 파일
3. **아이콘 이미지 파일**
4. **HTTPS**

<br/>

### PWA의 장점

1. **앱 개발 생산성 극대화**
    - 하나의 코드 베이스(웹)로 다양한 플랫폼에서 동작하는 설치형 앱을 빠르게 만들 수 있다.
    - 앱을 배포하고 업데이트할 때도 스토어의 심사와 리뷰를 거치지 않아도 되므로 중간 프로세스 생략가능
    - 즉, 네이티브 앱 개발에 비해 개발과 유지 보수 측면에서 비용 절감 가능
2. **검색 엔진을 통한 유입**
    - PWA는 본질적으로 웹이기 때문에, 검색 엔진을 통해 검색이 가능하며(SEO) 이를 통해 사용자가 유입될 수 있다.
3. **푸시 알림**
    - 네이티브 앱만이 가지고 있던 기능인 푸시 알림 지원 가능, 이를 통해 사용자 재참여 유도 가능
4. **저속도 네트워크 환경, 오프라인 동작 지원**
    - Service Worker 덕분에 앱 동작에 필요한 asset들과 일부 API call에 대한 캐싱이 가능

<br/>

### PWA의 단점

- PWA의 인지도 부족, 앱 설치의 애매함
    - 사용자 입장에서 스토어를 통해 설치한 앱은 그나마 안전하다는 인식을 가지고 있는데, PWA와 같이 ‘홈 화면 추가’ 기능을 통한 앱 설치 유도가 의심스러울 수 있다.
    - 구글과 MS는 스토어에 PWA를 배포할 수 있게 해두었지만, 애플 앱스토어의 경우 PWA 앱 배포가 쉽지 않다.
- Non-native UI
    - 네이티브 환경에서와 동일한 UI와 사용자 경험을 제공할 수 없다.
- 게임과 같은 고사양 앱 개발 불가능
    - 웹 기술이 발전하고는 있지만, OS의 자원을 직접적으로 사용할 수 있는 네이티브 앱의 퍼포먼스는 따라잡기 쉽지 않다. 따라서 높은 연산을 요구하거나, 그래픽 사용이 필수인 서비스를 개발하는 데에는 한계가 있다.

<br/>

## PWA의 핵심 구성 요소

### Web App Manifest

- 웹 앱이 사용자의 기기에 설치될 때 네이티브 앱처럼 보이고 동작할 수 있도록 필요한 **메타데이터**를 제공
- 웹 앱의 이름, 아이콘, 시작 URL, 표시 방식 등 앱의 기본 정보를 정의  
    → 이를 통해 웹 앱이 네이티브 앱처럼 보이고, 앱 런처에서 바로 실행될 수 있음
    
- 주요 속성
    - 필수 속성: `name` 또는 `short_name` 중 하나, `start_url`, `display`
    - 권장 속성: `icons`, `background_color`, `theme_color`
    
    | **속성명** | **설명** |
    | --- | --- |
    | **`name`** | 앱의 전체 이름, 아이콘의 이름으로 표시됨 |
    | **`short_name`** | 설치 배너에 표시되는 이름, 검색의 키워드로 사용됨 |
    | **`icons`** | 다양한 크기의 앱 아이콘 이미지 배열 |
    | **`start_url`** | 앱 실행 시 시작되는 URL |
    | **`display`** | 앱의 표시 방식(예: standalone, fullscreen, minimal-ui 등) |
    | **`background_color`** | 앱이 로딩될 때의 배경색 |
    | **`theme_color`** | 브라우저 UI에 적용되는 테마 색상 |
    | **`orientation`** | 앱의 기본 화면 방향(예: portrait, landscape 등) |
    | **`scope`** | 앱의 탐색 범위. 이 범위를 벗어나는 링크 클릭 시 브라우저로 이동 |  
- 예시 코드
    
    ```json
    {
      "name": "My Progressive Web App",
      "short_name": "MyPWA",
      "icons": [                     // 192px(128dp)이 있어야 스플래시 화면이 표시됨
        {
          "src": "icon-192x192.png",
          "sizes": "192x192",
          "type": "image/png"
        },
        {
          "src": "icon-512x512.png",
          "sizes": "512x512",
          "type": "image/png"
        }
      ],
      "start_url": "/",
      "display": "standalone",  // standalone을 가장 많이 사용 (상단의 URL 바 제거)
      "background_color": "#ffffff",
      "theme_color": "#3367D6",
      "orientation": "portrait"
    }
    ```
    
- 적용 방법
    - `manifest.json` 파일을 루트 디렉토리에 위치시키고, HTML의 `<head>` 태그에 `<link rel="manifest" href="/manifest.json">` 추가

<br/>

### Service Worker

- **브라우저의 백그라운드에서 동작하는 JavaScript 스크립트**  
    - 이벤트 기반 워커 → 특정 이벤트가 발생했을 때만 실행되는 백그라운드 스크립트
    - 브라우저의 **워커 스레드(worker thread)** 에서 실행
        - 메인 스레드: HTML, CSS, JavaScript를 렌더링하고 사용자와의 상호작용 담당
        - 워커 스레드: 웹 애플리케이션의 성능을 향상시키기 위해 사용되는 백그라운드 스레드
- 페이지와는 독립적으로 작동하여 네트워크 요청을 가로채거나 캐싱, 푸시 알림 등을 수행  
- PWA의 핵심 기술로, 오프라인 지원 및 사용자 재참여 유도 기능을 제공  
- 주요 기능
    
    
    | 기능 | 설명 |
    | --- | --- |
    | **캐싱 및 오프라인 지원** | 네트워크 연결이 없어도 앱이 동작하도록 정적 자원이나 API 응답 등을 캐싱 |
    | **푸시 알림** | 사용자에게 브라우저 기반 알림 전송 |
    | **백그라운드 동기화** | 네트워크가 복구되었을 때 서버와 자동으로 동기화 수행 |
    | **네트워크 요청 가로채기** | 요청을 수정하거나 캐시 우선/네트워크 우선 전략 등을 구현 가능 |
- 작동 생명주기
    1. **등록 (register)**
        - 앱 초기 구동 시 `navigator.serviceWorker.register()`로 등록
    2. **설치 (install)**
        - 캐싱할 리소스를 미리 저장 (precache)
    3. **활성화 (activate)**
        - 오래된 캐시 정리 및 현재 서비스 준비
    4. **이벤트 처리**
        - `fetch`, `push`, `sync` 등 다양한 이벤트에 대한 리스너 등록 가능
    5. **종료 및 재실행**
        - 리소스 절약을 위해 유휴 상태로 진입, 이벤트 발생 시 자동 재실행
- 주요 오프라인 캐싱 전략
    1. **Cache First** 
        - 먼저 캐시에서 응답을 찾고, 없으면 네트워크 요청
        - 장점: 빠른 응답, 오프라인에서도 동작 가능
        - 단점: 캐시가 오래된 경우 실제 데이터와 다른 데이터를 제공할 수 있음
    2. **Network First**
        - 항상 네트워크에서 요청 시도, 실패하면 캐시 사용
        - 장점: 최신 데이터 유지
        - 단점: 네트워크가 느리면 로딩 속도 저하, 오프라인 시 fallback 필수
    3. **Cache Only**
        - 오직 캐시에서만 리소스를 로드 (네트워크 요청 X)
        - 사전에 캐시된 자산만 접근할 수 있어야 할 때 사용
    4. **Network Only**
        - 무조건 네트워크 요청 (캐시 사용 X)
        - 인증 요청, 실시간 데이터가 필요할 때 사용
    5. **Stale While Revalidate**
        - 캐시된 응답을 즉시 반환하고, 동시에 네트워크에서 최신 응답을 받아 캐시 갱신
        - 장점: 빠른 응답 + 최신 데이터 유지
        - 단점: UI는 오래된 데이터를 잠깐 보여줄 수 있음
    
    | 상황 | 추천 전략 |
    | --- | --- |
    | 정적 자산 (HTML, CSS, JS, 이미지 등) | Cache First / Stale While Revalidate |
    | 자주 바뀌는 데이터 (API 응답) | Network First / Stale While Revalidate |
    | 민감하거나 유효기간 짧은 데이터 | Network Only |
    | 오프라인 전용 페이지 (fallback.html 등) | Cache Only |
- static caching과 dynamic caching
    - **static caching (정적 캐싱)**
        - 앱의 핵심 리소스를 서비스 워커 설치 시점에 미리 캐시에 저장(precache)해두는 방식
        - 장점
            - 앱 로딩 속도가 빠름
            - 항상 동일한 리소스를 제공하므로 예측 가능
        - 단점
            - 자주 변경되는 리소스에 부적합
            - 버전 관리 또는 캐시 무효화 전략 필요
    - **dynamic caching (동적 캐싱)**
        - 서비스 워커가 처음 요청된 리소스를 캐시에 저장한 뒤, 다음부터는 캐시에서 제공하는 방식
        - 장점
            - API 응답, 유저 업로드 이미지 같은 예측 불가능한 리소스도 캐싱 가능
            - 효율적인 캐시 사용 가능
        - 단점
            - 캐시 크기 관리 필요
            - 처음 로딩은 네트워크 요청에 의존 → offline 대비에 약함
    - **App Shell 아키텍쳐**
        - React, Vue 등 SPA 기반 앱에서 사용하는 PWA 설계 방식
        - **UI 뼈대(shell)는 미리 캐싱(static), 콘텐츠는 나중에 동적으로 로드(dynamic)** 하는 아키텍처
        - 예시
            - App Shell (캐시됨)
                - index.html
                - app.js (SPA 코드)
                - styles.css
            - Dynamic Content (API로 불러옴)
                - 포스트 리스트, 유저 프로필 데이터 등
        - 장점
            - 빠른 초기 렌더링 제공 (App Shell 캐시 덕분)
            - 콘텐츠만 새로고침 가능
    
    | 항목 | 설명 | 비고 |
    | --- | --- | --- |
    | Static Caching | 정적 리소스를 미리 캐싱 | `install` 단계에 저장 |
    | Dynamic Caching | 요청 시점에 캐싱 | API 응답이나 이미지에 적합 |
    | App Shell Architecture | 앱 틀은 캐싱, 콘텐츠는 동적 로딩 | SPA에 최적화된 패턴 |

<br/>

## 오프라인 UI/UX 설계 전략

1. **필수 자산 식별 및 사전 캐싱 (Static Caching)**
    - 앱 구동에 반드시 필요한 정적 파일들을 Service Worker의 install 단계에서 미리 캐싱
        - HTML, CSS, JS 번들, 아이콘 이미지, fallback 페이지 등
    - 이를 통해 사용자는 네트워크가 없어도 앱을 열 수 있고, 최소한의 기능을 제공받을 수 있음
2. **오프라인 페이지 준비 및 fallback 처리**
    - 오프라인 상태에서의 UX 저하 방지를 위해 대체 페이지(offline fallback page)를 준비
    - `Cache Only` 방식으로 중요한 페이지나 메시지를 캐싱해두고, 네트워크 연결이 없을 때 이를 사용자에게 표시
3. **API 응답 캐싱 (Dynamic Caching)**
    - 네트워크 요청 중 일부를 동적으로 캐싱
    - `Network First` 또는 `Stale While Revalidate` 전략 활용
4. **캐시 정리 및 버전 관리**
    - `activate` 단계에서 이전 버전의 캐시를 삭제하여 불필요한 저장 공간 사용 방지
    - 캐시 이름에 버전을 명시하고, 버전이 바뀔 때마다 갱신
5. **오프라인 데이터 저장소 (IndexedDB 등 활용)**
    - 복잡한 데이터 저장에는 IndexedDB와 같은 브라우저 내 저장소 활용
    - 사용자의 입력 데이터를 오프라인 상태에서 저장하고, 온라인 상태가 되면 서버와 동기화 (Background Sync 활용)
6. **사용자에게 오프라인 상태 알리기**
    - 앱 내에 오프라인 상태를 감지하고 사용자에게 알려주는 UI 구성
        
        ```jsx
        window.addEventListener('offline', () => showToast('현재 오프라인입니다'));
        window.addEventListener('online', () => showToast('온라인에 연결되었습니다'));
        ```
        
        | 항목 | 설명 |
        | --- | --- |
        | **명확한 메시지** | “오프라인 상태입니다”, “다시 시도해주세요” 등의 텍스트 |
        | **재시도 버튼** | 클릭 시 `window.location.reload()` 등으로 재요청 가능 |
        | **로컬 내비게이션** | 캐시된 페이지나 홈으로 돌아가는 링크 |
        | **캐시된 콘텐츠 보여주기** | 가능하면 `IndexedDB` 또는 캐시된 데이터를 렌더링 |
        | **심플하고 가벼운 디자인** | 불필요한 애니메이션, 외부 리소스는 지양 |

<br/>

## iOS 및 다양한 플랫폼 대응 이슈

### iOS의 PWA 제한사항

| 제한사항 | 설명 |
| --- | --- |
| **Service Worker 제한** | iOS 11.3 이상부터 지원되지만, 기능이 불완전하거나 일부 API 미지원 |
| **푸시 알림 미지원 (iOS 15 이하)** | Safari에서는 Web Push를 오랫동안 지원하지 않음 (iOS 16.4부터 도입) |
| **설치 유도 불편** | iOS에서는 `홈 화면에 추가`를 수동으로 안내해야 함 (자동 설치 배너 없음) |
| **백그라운드 실행 제한** | 메모리 절약을 위해 자주 서비스 워커가 중지됨 |
| **Storage 제한** | IndexedDB 등의 저장소 용량 제한이 더 빡빡함 |

> ✅ iOS 16.4부터 Safari에서 Web Push 지원됨 (사용자 동의 필요, 앱 설치 필수)

<br/>


### Android의 PWA 지원 현황

| 항목 | 설명 |
| --- | --- |
| **설치 배너 자동 제공** | `manifest` + `serviceWorker` 조건 만족 시 설치 제안 자동 표시 |
| **Web Push 완전 지원** | 백그라운드 푸시 알림 지원 |
| **파일 접근, 카메라 사용 등** | 대부분의 Web API 지원 (다만 보안상의 제한 있음) |
| **Play Store 등록 가능** | Trusted Web Activity(TWA)를 활용해 APK로 배포 가능 |